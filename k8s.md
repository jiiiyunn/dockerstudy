# 쿠버네티스(k8s)

컨테이너 기반의 애플리케이션을 개발하고 배포할 수 있도록 설계된 오픈 소스 플랫폼  
컨테이너 오케스트레이션 도구의 사실상 표준  
분산 시스템을 탄력적으로 실행하기 위한 프레임 워크를 제공  

- **서비스 디스커버리와 로드 밸런싱** 
쿠버네티스는 DNS 이름을 사용하거나 자체 IP 주소를 사용하여 컨테이너를 노출할 수 있다. 컨테이너에 대한 트래픽이 많으면, 쿠버네티스는 네트워크 트래픽을 로드밸런싱하고 배포하여 배포가 안정적으로 이루어질 수 있다.
- **스토리지 오케스트레이션** 
쿠버네티스를 사용하면 로컬 저장소, 공용 클라우드 공급자 등과 같이 원하는 저장소 시스템을 자동으로 탑재 가능
- **자동화된 롤아웃과 롤백** 
쿠버네티스를 사용하여 배포된 컨테이너의 원하는 상태를 서술할 수 있으며 현재 상태를 원하는 상태로 설정한 속도에 따라 변경할 수 있다. 예를 들어 쿠버네티스를 자동화해서 배포용 새 컨테이너를 만들고, 기존 컨테이너를 제거하고, 모든 리소스를 새 컨테이너에 적용할 수 있다.
→ 과부하 등에 따라 컨테이너의 개수를 유동적으로 관리
- **자동화된 빈 패킹(bin packing)** 
컨테이너화된 작업을 실행하는데 사용할 수 있는 쿠버네티스 클러스터 노드를 제공한다. 각 컨테이너가 필요로 하는 CPU와 메모리(RAM)를 쿠버네티스에게 지시한다. 쿠버네티스는 컨테이너를 노드에 맞추어서 리소스를 가장 잘 사용할 수 있도록 해준다.
- **자동화된 복구(self-healing)** 
쿠버네티스는 실패한 컨테이너를 다시 시작하고, 컨테이너를 교체하며, '사용자 정의 상태 검사'에 응답하지 않는 컨테이너를 죽이고, 서비스 준비가 끝날 때까지 그러한 과정을 클라이언트에 보여주지 않는다.
→ 만약 서버 하나가 죽는다면 다른 서버측으로 돌려준다
- **시크릿과 구성 관리** 
쿠버네티스를 사용하면 암호, OAuth 토큰 및 SSH 키와 같은 중요한 정보를 저장하고 관리할 수 있다. 컨테이너 이미지를 재구성하지 않고 스택 구성에 시크릿을 노출하지 않고도 시크릿 및 애플리케이션 구성을 배포 및 업데이트할 수 있다.
→ 예를 들어 설정정보를 가지고 있는 configmap 파일 등이 있을 때, 모든 컨테이너들이 이 파일을 참조하게 해서 이 파일 하나의 내용만 바꾸어도 다른 컨테이너에 적용되게 할 수 있음

## 쿠버네티스 컴포넌트
쿠버네티스 클러스터는 컨테이너화 된 애플리캐이션을 실행하는 노드의 집합.  

### 마스터 노드(컨트롤 플레인 컴포넌트)
클러스터에 관한 전반적인 결정. 제어판의 역할-control plane   
- kube-apiserver
- etcd
- kube-scheduler
- kube-controller-manager
- cloud-controller-manager

### 워커 노드(노드 컴포넌트)
- kubelet
- kube-proxy
- 컨테이너 런타임

### Cluster API
쿠버네티스 클러스터 구성을 선언적인 형태로 작성하고 자동으로 생성하고 관리하는 방법을 제공  
  -> 라이프사이클 관리
다양한 인프라 환경에서 일관되고 반복적인 클러스터 배포 가능  
외부에서 어떤 기능을 호출했을 때 그에 따른 로직을 모아둔 곳에서 특정 함수에 대한 기능을 보내준다


