# 쿠버네티스(k8s)

컨테이너 기반의 애플리케이션을 개발하고 배포할 수 있도록 설계된 오픈 소스 플랫폼  
컨테이너 오케스트레이션 도구의 사실상 표준  
분산 시스템을 탄력적으로 실행하기 위한 프레임 워크를 제공  

- **서비스 디스커버리와 로드 밸런싱**   
쿠버네티스는 DNS 이름을 사용하거나 자체 IP 주소를 사용하여 컨테이너를 노출할 수 있다. 컨테이너에 대한 트래픽이 많으면, 쿠버네티스는 네트워크 트래픽을 로드밸런싱하고 배포하여 배포가 안정적으로 이루어질 수 있다.
- **스토리지 오케스트레이션**   
쿠버네티스를 사용하면 로컬 저장소, 공용 클라우드 공급자 등과 같이 원하는 저장소 시스템을 자동으로 탑재 가능
- **자동화된 롤아웃과 롤백**   
쿠버네티스를 사용하여 배포된 컨테이너의 원하는 상태를 서술할 수 있으며 현재 상태를 원하는 상태로 설정한 속도에 따라 변경할 수 있다. 예를 들어 쿠버네티스를 자동화해서 배포용 새 컨테이너를 만들고, 기존 컨테이너를 제거하고, 모든 리소스를 새 컨테이너에 적용할 수 있다.
→ 과부하 등에 따라 컨테이너의 개수를 유동적으로 관리
- **자동화된 빈 패킹(bin packing)**   
컨테이너화된 작업을 실행하는데 사용할 수 있는 쿠버네티스 클러스터 노드를 제공한다. 각 컨테이너가 필요로 하는 CPU와 메모리(RAM)를 쿠버네티스에게 지시한다. 쿠버네티스는 컨테이너를 노드에 맞추어서 리소스를 가장 잘 사용할 수 있도록 해준다.
- **자동화된 복구(self-healing)**   
쿠버네티스는 실패한 컨테이너를 다시 시작하고, 컨테이너를 교체하며, '사용자 정의 상태 검사'에 응답하지 않는 컨테이너를 죽이고, 서비스 준비가 끝날 때까지 그러한 과정을 클라이언트에 보여주지 않는다.
→ 만약 서버 하나가 죽는다면 다른 서버측으로 돌려준다
- **시크릿과 구성 관리**   
쿠버네티스를 사용하면 암호, OAuth 토큰 및 SSH 키와 같은 중요한 정보를 저장하고 관리할 수 있다. 컨테이너 이미지를 재구성하지 않고 스택 구성에 시크릿을 노출하지 않고도 시크릿 및 애플리케이션 구성을 배포 및 업데이트할 수 있다.
→ 예를 들어 설정정보를 가지고 있는 configmap 파일 등이 있을 때, 모든 컨테이너들이 이 파일을 참조하게 해서 이 파일 하나의 내용만 바꾸어도 다른 컨테이너에 적용되게 할 수 있음

## 쿠버네티스 컴포넌트
쿠버네티스 클러스터는 컨테이너화 된 애플리캐이션을 실행하는 노드의 집합.  

![Alt text](/statics/image.png)
![Alt text](/statics/image2.png)

### 마스터 노드(컨트롤 플레인 컴포넌트)
클러스터에 관한 전반적인 결정. 제어판의 역할-control plane   
- kube-apiserver
- etcd
- kube-scheduler
- kube-controller-manager
- cloud-controller-manager

### 워커 노드(노드 컴포넌트)
- kubelet
- kube-proxy
- 컨테이너 런타임

### Cluster API
쿠버네티스 컨트롤 플레인의 프론트엔드  
사용자가 쿠버네티스 클러스터와 상호 작용하는 방식  
쿠버네티스 클러스터 구성을 선언적인 형태로 작성하고 자동으로 생성하고 관리하는 방법을 제공  
  -> 라이프사이클 관리

다양한 인프라 환경에서 일관되고 반복적인 클러스터 배포 가능  
외부에서 어떤 기능을 호출했을 때 그에 따른 로직을 모아둔 곳에서 특정 함수에 대한 기능을 보내준다

### 배포 과정
![Alt text](/statics/image1.png)

* app descriptor: 내가 어떻게 묶을 것인지, 어떻게 구성할지 기재한 명세서
* kudectl을 통해 control plane으로 전달 -> node에 분배
* 어디에 배치할지는 Scheduler가 결정하지만 실제로 배치를 명령하는 것은 Kubelet의 역할
* 이 상태들은 control plane 안에 있는 etcd에 저장

### kubectl
쿠버네티스 클러스터를 관리하는 명령행 도구(CLI)  
로컬 환경, 매니지드 환경 모두 사용 가능  
쿠버네티스 자원을 생성, 업데이트, 삭제(create, update, delete)  
디버그, 모니터링, 트러블 슈팅(log, exec, cp, top, attach…)  
클러스터 관리(cordon, top, drain, taint…)  


# 쿠버네티스 리소스
**node**	컨테이너를 배치하는 서버   
**namespace**	쿠버네티스 클러스터 안의 가상 클러스터  
단일 클러스터 내에서의 리소스 그룹 격리 메커니즘  
**pod**	컨테이너 집합 중 가장 작은 단위로 컨테이너의 실행 방법을 정의. 컨테이너와 볼륨을 묶은 것  
**replicaset**   같은 스펙을 갖는 파드를 여러 개 생성하고 관리  
**deployment**  replicaset의 리비전(버전)을 관리  
**service** 파드에 집합에 접근하기 위한 경로를 정의   
**ingress** 서비스를 쿠버네티스 클러스트의 외부로 노출(통합)  
**configmap** 설정정보 저장   
**persistentvolume** 파드가 사용할 스토리지의 크기 및 종류를 정의  
**persistentvolumeclaim**  퍼시스턴트 볼륨을 동적으로 확보  
**job**  상주 실행을 목적으로 하지 않는 파드를 여러 개 생성하고 정상적인 종료를 보장  
**clonejob** cron문법으로 스케쥴링되는 job. 정해진 시간에 동작  
**secrets** 인증정보와 같은 기밀 데이터를 정의하고 전해줌  

## 파드(pod)
- 컨테이너 애플리케이션의 기본 단위  
- **단일 목적**을 수행하기 위한 **한 개 이상의 컨테이너로 구성**된 컨테이너의 집합
- 여러 리눅스 네임스페이스를 공유하는 **여러 컨테이너들을 추상화된 집합으로 사용**하기 위함

> **초기화 컨테이너(init container)**   
> 파드의 앱 컨테이너들이 실행되기 전에 실행되는 특수한 컨테이너  
> 앱 이미지에는 없는 셋업을 위한 유틸리티 또는 설정 스크립트 등을 포함할 수 있음  
> 이번의 경우에는 사이드카 패턴에서 쓰인 공유볼륨에 날짜별로 디렉토리생성 후 소유자권한을 바꿔놓는? 미리 세팅하는 개념  
> 
> **일반적인 컨테이너와의 차이점**
> - 앱 컨테이너의 리소스 상한, 볼륨, 보안 셋팅을 포함한 모든 필드와 기능을 지원
> - 파드가 준비상태가 되기 전에 완료를 목표로 실행되어야 하므로, lifecycle, livenessProbe, readinessProbe, startupProbe을 지원하지 않음
> 
### 파드의 헬스 체크 기능

파드와 컨테이너에는 애플리케이션이 정상적으로 기동하고 있는지 확인하는 기능(=헬스 체크 기능)을 설정할 수 있으며 이상이 감지되면 컨테이너를 강제 종료하고 재시작할 수 있음(kubelet이 담당)

kubelet의 헬스 체크는 활성 프로브(Liveness Probe)와 준비 상태 프로브(Readiness Probe)를 사용하여 실행 중인 파드의 컨테이너를 검사

**활성 프로브(Liveness Probe)**

- 컨테이너의 애플리케이션이 **정상적으로 실행** 중인 것을 검사
- 검사에 실패하면 파드 상의 컨테이너를 강제로 종료하고 재시작
- 이 기능을 사용하기 위해서는 매니페스트에 명시적으로 설정해야 함

**준비 상태 프로브(Readiness Probe)**

- 컨테이너의 애플리케이션이 **요청을 받을 준비**가 되었는지를 검사

## 레플리카셋(replicaset)
**일정 개수의 파드를 유지**하는 컨트롤러
- 정해진 수의 동일한 파드가 항상 실행되도록 관리
- 노드 장애 등의 이유로 파드를 사용할 수 없다면 다른 노드에 파드를 다시 생성

시크릿 생성 및 확인(pull 횟수로 인해 안되는 경우)   
도커 허브에서 이미지를 가져올 때 사용할 자격증명 정보를 저장할 시크릿을 생성  
컨테이너가 죽으면 파드가 살려주는데 파드가 죽으면 모니터링 관리자가 확인하기 전까지 모름! 그래서 나온게 레플리카셋!

### 레플리카셋의 동작 원리

- 라벨 셀렉터(Label Selector)를 이용해서 유지할 파드를 정의
- 레플리카셋은 spec.selector.macthLabels에 정의된 라벨을 통해 생성해야 하는 파드를 찾음
→ app: my-nginx-pods-label
- 라벨을 가지는 파드의 개수가 replicas 항목에 정의된 숫자보다 적으면 파드를 정의하는 파드 템플릿(template) 내용으로 파드를 생성
  
## 디플로이먼트(Deployment)

- 레플리카셋 관리+파드 배포에 최적화(버전관리)
- 애플리케이션의 **배포와 업데이트**를 편하게 하기 위해서 사용!
- 쿠버네티스에서 **상태가 없는(stateless) 애플리케이션을 배포**할 때 사용하는 가장 기본적인 컨트롤러


> **stateless**   
> 상태: 요청과 응답간의 관계  
> 요청1(선행요청)이 가고 요청2가 갔을 때 이 두개의 요청간의 관계를 안다면 상태가 있다고 전제  
> 선후관계를 따지지않고 요청에 맞는 처리만 해주는 것 모든 요청을 동등하게 보는 것

- 디플로이먼트는 **스케일, 롤아웃, 롤백, 자동복구** 기능이 있음

**스케일** 파드의 개수를 늘리거나 줄일 수 있음  
**롤아웃, 롤백** 서비스를 유지하면서 파드를 교체  
**자동복구** 노드 수준에서 장애가 발생했을 때 파드를 복구하는 것이 가능

### 디플로이먼트를 사용하는 이유 1. 스케일

- 레플리카의 값을 변경해서 파드의 개수를 조절
  → 처리능력을 높이고 낮추는 기능
- 파드의 개수를 늘리는 중에 쿠버네티스 클러스터의 자원(CPU,  메모리 등)이 부족해지면 노드를 추가하여 자원이 생길때 까지 파드 생성을 **보류**


### 디플로이먼트를 사용하는 이유 2. 롤아웃, 롤백

애플리케이션을 업데이트할 때 레플리카셋의 변경사항을 저장하는 **리비전(revision)을 남겨 롤백을 가능**하게 해주고, 무중단서비스를 위해 **파드의 롤링 업데이트 전략(배포전략)**을 지정할 수 있음


# 오브젝트(objects)


## 컨트롤러(controler)
파드의 실행을 제어하는 오브젝트
![Alt text](/statics/imagecontroler.png)

